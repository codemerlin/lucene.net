/*
 * This code is derived from MyJavaLibrary (http://somelinktomycoollibrary)
 * 
 * If this is an open source Java library, include the proper license and copyright attributions here!
 */

using System.Collections.Generic;
using System.IO;
using Lucene.Net.Analysis;
using Lucene.Net.Queryparser.Classic;
using Lucene.Net.Search;
using Lucene.Net.Util;
using Sharpen;

namespace Lucene.Net.Queryparser.Classic
{
	/// <summary>This class is generated by JavaCC.</summary>
	/// <remarks>
	/// This class is generated by JavaCC.  The most important method is
	/// <see cref="QueryParserBase.Parse(string)">QueryParserBase.Parse(string)</see>
	/// .
	/// The syntax for query strings is as follows:
	/// A Query is a series of clauses.
	/// A clause may be prefixed by:
	/// <ul>
	/// <li> a plus (<code>+</code>) or a minus (<code>-</code>) sign, indicating
	/// that the clause is required or prohibited respectively; or
	/// <li> a term followed by a colon, indicating the field to be searched.
	/// This enables one to construct queries which search multiple fields.
	/// </ul>
	/// A clause may be either:
	/// <ul>
	/// <li> a term, indicating all the documents that contain this term; or
	/// <li> a nested query, enclosed in parentheses.  Note that this may be used
	/// with a <code>+</code>/<code>-</code> prefix to require any of a set of
	/// terms.
	/// </ul>
	/// Thus, in BNF, the query grammar is:
	/// <pre>
	/// Query  ::= ( Clause )
	/// Clause ::= ["+", "-"] [&lt;TERM&gt; ":"] ( &lt;TERM&gt; | "(" Query ")" )
	/// </pre>
	/// <p>
	/// Examples of appropriately formatted queries can be found in the &lt;a
	/// href="
	/// <docRoot></docRoot>
	/// /org/apache/lucene/queryparser/classic/package-summary.html#package_description"&gt;query syntax
	/// documentation</a>.
	/// </p>
	/// <p>
	/// In
	/// <see cref="Lucene.Net.Search.TermRangeQuery">Lucene.Net.Search.TermRangeQuery
	/// 	</see>
	/// s, QueryParser tries to detect date values, e.g.
	/// <tt>date:[6/1/2005 TO 6/4/2005]</tt> produces a range query that searches
	/// for "date" fields between 2005-06-01 and 2005-06-04. Note that the format
	/// of the accepted input depends on
	/// <see cref="QueryParserBase.SetLocale(System.Globalization.CultureInfo)">the locale
	/// 	</see>
	/// .
	/// A
	/// <see cref="Lucene.Net.Document.DateTools.Resolution">Lucene.Net.Document.DateTools.Resolution
	/// 	</see>
	/// has to be set,
	/// if you want to use
	/// <see cref="Lucene.Net.Document.DateTools">Lucene.Net.Document.DateTools
	/// 	</see>
	/// for date conversion.
	/// </p>
	/// <p>
	/// The date resolution that shall be used for RangeQueries can be set
	/// using
	/// <see cref="QueryParserBase.SetDateResolution(Lucene.Net.Document.DateTools.Resolution)
	/// 	">QueryParserBase.SetDateResolution(Lucene.Net.Document.DateTools.Resolution)
	/// 	</see>
	/// or
	/// <see cref="QueryParserBase.SetDateResolution(string, Lucene.Net.Document.DateTools.Resolution)
	/// 	">QueryParserBase.SetDateResolution(string, Lucene.Net.Document.DateTools.Resolution)
	/// 	</see>
	/// . The former
	/// sets the default date resolution for all fields, whereas the latter can
	/// be used to set field specific date resolutions. Field specific date
	/// resolutions take, if set, precedence over the default date resolution.
	/// </p>
	/// <p>
	/// If you don't use
	/// <see cref="Lucene.Net.Document.DateTools">Lucene.Net.Document.DateTools
	/// 	</see>
	/// in your index, you can create your own
	/// query parser that inherits QueryParser and overwrites
	/// <see cref="QueryParserBase.GetRangeQuery(string, string, string, bool, bool)">QueryParserBase.GetRangeQuery(string, string, string, bool, bool)
	/// 	</see>
	/// to
	/// use a different method for date conversion.
	/// </p>
	/// <p>Note that QueryParser is <em>not</em> thread-safe.</p>
	/// <p><b>NOTE</b>: there is a new QueryParser in contrib, which matches
	/// the same syntax as this class, but is more modular,
	/// enabling substantial customization to how a query is created.
	/// <a name="version"/>
	/// <p><b>NOTE</b>: You must specify the required
	/// <see cref="Lucene.Net.Util.Version">Lucene.Net.Util.Version</see>
	/// compatibility when creating QueryParser:
	/// <ul>
	/// <li> As of 3.1,
	/// <see cref="QueryParserBase.SetAutoGeneratePhraseQueries(bool)">QueryParserBase.SetAutoGeneratePhraseQueries(bool)
	/// 	</see>
	/// is false by
	/// default.
	/// </ul>
	/// </remarks>
	public class QueryParser : QueryParserBase, QueryParserConstants
	{
		/// <summary>The default operator for parsing queries.</summary>
		/// <remarks>
		/// The default operator for parsing queries.
		/// Use
		/// <see cref="QueryParserBase.SetDefaultOperator(Operator)">QueryParserBase.SetDefaultOperator(Operator)
		/// 	</see>
		/// to change it.
		/// </remarks>
		public enum Operator
		{
			OR,
			AND
		}

		/// <summary>Create a query parser.</summary>
		/// <remarks>Create a query parser.</remarks>
		/// <param name="matchVersion">Lucene version to match. See <a href="#version">above</a>.
		/// 	</param>
		/// <param name="f">the default field for query terms.</param>
		/// <param name="a">used to find terms in the query text.</param>
		public QueryParser(Version matchVersion, string f, Analyzer a) : this(new FastCharStream
			(new StringReader(string.Empty)))
		{
			Init(matchVersion, f, a);
		}

		// *   Query  ::= ( Clause )*
		// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public int Conjunction()
		{
			int ret = CONJ_NONE;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case AND:
				case OR:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case AND:
						{
							Jj_consume_token(AND);
							ret = CONJ_AND;
							break;
						}

						case OR:
						{
							Jj_consume_token(OR);
							ret = CONJ_OR;
							break;
						}

						default:
						{
							jj_la1[0] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					break;
				}

				default:
				{
					jj_la1[1] = jj_gen;
					break;
				}
			}
			{
				if (true)
				{
					return ret;
				}
			}
			throw new Error("Missing return statement in function");
		}

		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public int Modifiers()
		{
			int ret = MOD_NONE;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case NOT:
				case PLUS:
				case MINUS:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case PLUS:
						{
							Jj_consume_token(PLUS);
							ret = MOD_REQ;
							break;
						}

						case MINUS:
						{
							Jj_consume_token(MINUS);
							ret = MOD_NOT;
							break;
						}

						case NOT:
						{
							Jj_consume_token(NOT);
							ret = MOD_NOT;
							break;
						}

						default:
						{
							jj_la1[2] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					break;
				}

				default:
				{
					jj_la1[3] = jj_gen;
					break;
				}
			}
			{
				if (true)
				{
					return ret;
				}
			}
			throw new Error("Missing return statement in function");
		}

		// This makes sure that there is no garbage after the query string
		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public sealed override Lucene.Net.Search.Query TopLevelQuery(string field)
		{
			Lucene.Net.Search.Query q;
			q = Query(field);
			Jj_consume_token(0);
			{
				if (true)
				{
					return q;
				}
			}
			throw new Error("Missing return statement in function");
		}

		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public Lucene.Net.Search.Query Query(string field)
		{
			IList<BooleanClause> clauses = new AList<BooleanClause>();
			Lucene.Net.Search.Query q;
			Lucene.Net.Search.Query firstQuery = null;
			int conj;
			int mods;
			mods = Modifiers();
			q = Clause(field);
			AddClause(clauses, CONJ_NONE, mods, q);
			if (mods == MOD_NONE)
			{
				firstQuery = q;
			}
			while (true)
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case AND:
					case OR:
					case NOT:
					case PLUS:
					case MINUS:
					case BAREOPER:
					case LPAREN:
					case STAR:
					case QUOTED:
					case TERM:
					case PREFIXTERM:
					case WILDTERM:
					case REGEXPTERM:
					case RANGEIN_START:
					case RANGEEX_START:
					case NUMBER:
					{
						break;
					}

					default:
					{
						jj_la1[4] = jj_gen;
						goto label_1_break;
						break;
					}
				}
				conj = Conjunction();
				mods = Modifiers();
				q = Clause(field);
				AddClause(clauses, conj, mods, q);
label_1_continue: ;
			}
label_1_break: ;
			if (clauses.Count == 1 && firstQuery != null)
			{
				if (true)
				{
					return firstQuery;
				}
			}
			else
			{
				{
					if (true)
					{
						return GetBooleanQuery(clauses);
					}
				}
			}
			throw new Error("Missing return statement in function");
		}

		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public Lucene.Net.Search.Query Clause(string field)
		{
			Lucene.Net.Search.Query q;
			Token fieldToken = null;
			Token boost = null;
			if (Jj_2_1(2))
			{
				switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
				{
					case TERM:
					{
						fieldToken = Jj_consume_token(TERM);
						Jj_consume_token(COLON);
						field = DiscardEscapeChar(fieldToken.image);
						break;
					}

					case STAR:
					{
						Jj_consume_token(STAR);
						Jj_consume_token(COLON);
						field = "*";
						break;
					}

					default:
					{
						jj_la1[5] = jj_gen;
						Jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case BAREOPER:
				case STAR:
				case QUOTED:
				case TERM:
				case PREFIXTERM:
				case WILDTERM:
				case REGEXPTERM:
				case RANGEIN_START:
				case RANGEEX_START:
				case NUMBER:
				{
					q = Term(field);
					break;
				}

				case LPAREN:
				{
					Jj_consume_token(LPAREN);
					q = Query(field);
					Jj_consume_token(RPAREN);
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case CARAT:
						{
							Jj_consume_token(CARAT);
							boost = Jj_consume_token(NUMBER);
							break;
						}

						default:
						{
							jj_la1[6] = jj_gen;
							break;
						}
					}
					break;
				}

				default:
				{
					jj_la1[7] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return HandleBoost(q, boost);
				}
			}
			throw new Error("Missing return statement in function");
		}

		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		public Lucene.Net.Search.Query Term(string field)
		{
			Token term;
			Token boost = null;
			Token fuzzySlop = null;
			Token goop1;
			Token goop2;
			bool prefix = false;
			bool wildcard = false;
			bool fuzzy = false;
			bool regexp = false;
			bool startInc = false;
			bool endInc = false;
			Lucene.Net.Search.Query q;
			switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
			{
				case BAREOPER:
				case STAR:
				case TERM:
				case PREFIXTERM:
				case WILDTERM:
				case REGEXPTERM:
				case NUMBER:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case TERM:
						{
							term = Jj_consume_token(TERM);
							break;
						}

						case STAR:
						{
							term = Jj_consume_token(STAR);
							wildcard = true;
							break;
						}

						case PREFIXTERM:
						{
							term = Jj_consume_token(PREFIXTERM);
							prefix = true;
							break;
						}

						case WILDTERM:
						{
							term = Jj_consume_token(WILDTERM);
							wildcard = true;
							break;
						}

						case REGEXPTERM:
						{
							term = Jj_consume_token(REGEXPTERM);
							regexp = true;
							break;
						}

						case NUMBER:
						{
							term = Jj_consume_token(NUMBER);
							break;
						}

						case BAREOPER:
						{
							term = Jj_consume_token(BAREOPER);
							term.image = Sharpen.Runtime.Substring(term.image, 0, 1);
							break;
						}

						default:
						{
							jj_la1[8] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case FUZZY_SLOP:
						{
							fuzzySlop = Jj_consume_token(FUZZY_SLOP);
							fuzzy = true;
							break;
						}

						default:
						{
							jj_la1[9] = jj_gen;
							break;
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case CARAT:
						{
							Jj_consume_token(CARAT);
							boost = Jj_consume_token(NUMBER);
							switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
							{
								case FUZZY_SLOP:
								{
									fuzzySlop = Jj_consume_token(FUZZY_SLOP);
									fuzzy = true;
									break;
								}

								default:
								{
									jj_la1[10] = jj_gen;
									break;
								}
							}
							break;
						}

						default:
						{
							jj_la1[11] = jj_gen;
							break;
						}
					}
					q = HandleBareTokenQuery(field, term, fuzzySlop, prefix, wildcard, fuzzy, regexp);
					break;
				}

				case RANGEIN_START:
				case RANGEEX_START:
				{
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case RANGEIN_START:
						{
							Jj_consume_token(RANGEIN_START);
							startInc = true;
							break;
						}

						case RANGEEX_START:
						{
							Jj_consume_token(RANGEEX_START);
							break;
						}

						default:
						{
							jj_la1[12] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case RANGE_GOOP:
						{
							goop1 = Jj_consume_token(RANGE_GOOP);
							break;
						}

						case RANGE_QUOTED:
						{
							goop1 = Jj_consume_token(RANGE_QUOTED);
							break;
						}

						default:
						{
							jj_la1[13] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case RANGE_TO:
						{
							Jj_consume_token(RANGE_TO);
							break;
						}

						default:
						{
							jj_la1[14] = jj_gen;
							break;
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case RANGE_GOOP:
						{
							goop2 = Jj_consume_token(RANGE_GOOP);
							break;
						}

						case RANGE_QUOTED:
						{
							goop2 = Jj_consume_token(RANGE_QUOTED);
							break;
						}

						default:
						{
							jj_la1[15] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case RANGEIN_END:
						{
							Jj_consume_token(RANGEIN_END);
							endInc = true;
							break;
						}

						case RANGEEX_END:
						{
							Jj_consume_token(RANGEEX_END);
							break;
						}

						default:
						{
							jj_la1[16] = jj_gen;
							Jj_consume_token(-1);
							throw new ParseException();
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case CARAT:
						{
							Jj_consume_token(CARAT);
							boost = Jj_consume_token(NUMBER);
							break;
						}

						default:
						{
							jj_la1[17] = jj_gen;
							break;
						}
					}
					bool startOpen = false;
					bool endOpen = false;
					if (goop1.kind == RANGE_QUOTED)
					{
						goop1.image = Sharpen.Runtime.Substring(goop1.image, 1, goop1.image.Length - 1);
					}
					else
					{
						if ("*".Equals(goop1.image))
						{
							startOpen = true;
						}
					}
					if (goop2.kind == RANGE_QUOTED)
					{
						goop2.image = Sharpen.Runtime.Substring(goop2.image, 1, goop2.image.Length - 1);
					}
					else
					{
						if ("*".Equals(goop2.image))
						{
							endOpen = true;
						}
					}
					q = GetRangeQuery(field, startOpen ? null : DiscardEscapeChar(goop1.image), endOpen
						 ? null : DiscardEscapeChar(goop2.image), startInc, endInc);
					break;
				}

				case QUOTED:
				{
					term = Jj_consume_token(QUOTED);
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case FUZZY_SLOP:
						{
							fuzzySlop = Jj_consume_token(FUZZY_SLOP);
							break;
						}

						default:
						{
							jj_la1[18] = jj_gen;
							break;
						}
					}
					switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
					{
						case CARAT:
						{
							Jj_consume_token(CARAT);
							boost = Jj_consume_token(NUMBER);
							break;
						}

						default:
						{
							jj_la1[19] = jj_gen;
							break;
						}
					}
					q = HandleQuotedTerm(field, term, fuzzySlop);
					break;
				}

				default:
				{
					jj_la1[20] = jj_gen;
					Jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
				{
					return HandleBoost(q, boost);
				}
			}
			throw new Error("Missing return statement in function");
		}

		private bool Jj_2_1(int xla)
		{
			jj_la = xla;
			jj_lastpos = jj_scanpos = token;
			try
			{
				return !Jj_3_1();
			}
			catch (QueryParser.LookaheadSuccess)
			{
				return true;
			}
			finally
			{
				Jj_save(0, xla);
			}
		}

		private bool Jj_3R_2()
		{
			if (Jj_scan_token(TERM))
			{
				return true;
			}
			if (Jj_scan_token(COLON))
			{
				return true;
			}
			return false;
		}

		private bool Jj_3_1()
		{
			Token xsp;
			xsp = jj_scanpos;
			if (Jj_3R_2())
			{
				jj_scanpos = xsp;
				if (Jj_3R_3())
				{
					return true;
				}
			}
			return false;
		}

		private bool Jj_3R_3()
		{
			if (Jj_scan_token(STAR))
			{
				return true;
			}
			if (Jj_scan_token(COLON))
			{
				return true;
			}
			return false;
		}

		/// <summary>Generated Token Manager.</summary>
		/// <remarks>Generated Token Manager.</remarks>
		public QueryParserTokenManager token_source;

		/// <summary>Current token.</summary>
		/// <remarks>Current token.</remarks>
		public Token token;

		/// <summary>Next token.</summary>
		/// <remarks>Next token.</remarks>
		public Token jj_nt;

		private int jj_ntk;

		private Token jj_scanpos;

		private Token jj_lastpos;

		private int jj_la;

		private int jj_gen;

		private readonly int[] jj_la1 = new int[21];

		private static int[] jj_la1_0;

		private static int[] jj_la1_1;

		static QueryParser()
		{
			Jj_la1_init_0();
			Jj_la1_init_1();
		}

		private static void Jj_la1_init_0()
		{
			jj_la1_0 = new int[] { unchecked((int)(0x300)), unchecked((int)(0x300)), unchecked(
				(int)(0x1c00)), unchecked((int)(0x1c00)), unchecked((int)(0xfda7f00)), unchecked(
				(int)(0x120000)), unchecked((int)(0x40000)), unchecked((int)(0xfda6000)), unchecked(
				(int)(0x9d22000)), unchecked((int)(0x200000)), unchecked((int)(0x200000)), unchecked(
				(int)(0x40000)), unchecked((int)(0x6000000)), unchecked((int)(0x80000000)), unchecked(
				(int)(0x10000000)), unchecked((int)(0x80000000)), unchecked((int)(0x60000000)), 
				unchecked((int)(0x40000)), unchecked((int)(0x200000)), unchecked((int)(0x40000))
				, unchecked((int)(0xfda2000)) };
		}

		private static void Jj_la1_init_1()
		{
			jj_la1_1 = new int[] { unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int
				)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0))
				, unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x1)), unchecked((int)(0x0)), unchecked((int)(0x1)), unchecked((int)(0x0))
				, unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked((int)(0x0)), unchecked(
				(int)(0x0)) };
		}

		private readonly QueryParser.JJCalls[] jj_2_rtns = new QueryParser.JJCalls[1];

		private bool jj_rescan = false;

		private int jj_gc = 0;

		/// <summary>Constructor with user supplied CharStream.</summary>
		/// <remarks>Constructor with user supplied CharStream.</remarks>
		protected internal QueryParser(CharStream stream)
		{
			token_source = new QueryParserTokenManager(stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 21; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new QueryParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		/// <remarks>Reinitialise.</remarks>
		public override void ReInit(CharStream stream)
		{
			token_source.ReInit(stream);
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 21; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new QueryParser.JJCalls();
			}
		}

		/// <summary>Constructor with generated Token Manager.</summary>
		/// <remarks>Constructor with generated Token Manager.</remarks>
		protected internal QueryParser(QueryParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 21; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new QueryParser.JJCalls();
			}
		}

		/// <summary>Reinitialise.</summary>
		/// <remarks>Reinitialise.</remarks>
		public virtual void ReInit(QueryParserTokenManager tm)
		{
			token_source = tm;
			token = new Token();
			jj_ntk = -1;
			jj_gen = 0;
			for (int i = 0; i < 21; i++)
			{
				jj_la1[i] = -1;
			}
			for (int i_1 = 0; i_1 < jj_2_rtns.Length; i_1++)
			{
				jj_2_rtns[i_1] = new QueryParser.JJCalls();
			}
		}

		/// <exception cref="Lucene.Net.Queryparser.Classic.ParseException"></exception>
		private Token Jj_consume_token(int kind)
		{
			Token oldToken;
			if ((oldToken = token).next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			if (token.kind == kind)
			{
				jj_gen++;
				if (++jj_gc > 100)
				{
					jj_gc = 0;
					for (int i = 0; i < jj_2_rtns.Length; i++)
					{
						QueryParser.JJCalls c = jj_2_rtns[i];
						while (c != null)
						{
							if (c.gen < jj_gen)
							{
								c.first = null;
							}
							c = c.next;
						}
					}
				}
				return token;
			}
			token = oldToken;
			jj_kind = kind;
			throw GenerateParseException();
		}

		[System.Serializable]
		private sealed class LookaheadSuccess : Error
		{
		}

		private readonly QueryParser.LookaheadSuccess jj_ls = new QueryParser.LookaheadSuccess
			();

		private bool Jj_scan_token(int kind)
		{
			if (jj_scanpos == jj_lastpos)
			{
				jj_la--;
				if (jj_scanpos.next == null)
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.GetNextToken();
				}
				else
				{
					jj_lastpos = jj_scanpos = jj_scanpos.next;
				}
			}
			else
			{
				jj_scanpos = jj_scanpos.next;
			}
			if (jj_rescan)
			{
				int i = 0;
				Token tok = token;
				while (tok != null && tok != jj_scanpos)
				{
					i++;
					tok = tok.next;
				}
				if (tok != null)
				{
					Jj_add_error_token(kind, i);
				}
			}
			if (jj_scanpos.kind != kind)
			{
				return true;
			}
			if (jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				throw jj_ls;
			}
			return false;
		}

		/// <summary>Get the next Token.</summary>
		/// <remarks>Get the next Token.</remarks>
		public Token GetNextToken()
		{
			if (token.next != null)
			{
				token = token.next;
			}
			else
			{
				token = token.next = token_source.GetNextToken();
			}
			jj_ntk = -1;
			jj_gen++;
			return token;
		}

		/// <summary>Get the specific Token.</summary>
		/// <remarks>Get the specific Token.</remarks>
		public Token GetToken(int index)
		{
			Token t = token;
			for (int i = 0; i < index; i++)
			{
				if (t.next != null)
				{
					t = t.next;
				}
				else
				{
					t = t.next = token_source.GetNextToken();
				}
			}
			return t;
		}

		private int Jj_ntk()
		{
			if ((jj_nt = token.next) == null)
			{
				return (jj_ntk = (token.next = token_source.GetNextToken()).kind);
			}
			else
			{
				return (jj_ntk = jj_nt.kind);
			}
		}

		private IList<int[]> jj_expentries = new AList<int[]>();

		private int[] jj_expentry;

		private int jj_kind = -1;

		private int[] jj_lasttokens = new int[100];

		private int jj_endpos;

		private void Jj_add_error_token(int kind, int pos)
		{
			if (pos >= 100)
			{
				return;
			}
			if (pos == jj_endpos + 1)
			{
				jj_lasttokens[jj_endpos++] = kind;
			}
			else
			{
				if (jj_endpos != 0)
				{
					jj_expentry = new int[jj_endpos];
					for (int i = 0; i < jj_endpos; i++)
					{
						jj_expentry[i] = jj_lasttokens[i];
					}
					for (Iterator<object> it = jj_expentries.Iterator(); it.HasNext(); )
					{
						int[] oldentry = (int[])(it.Next());
						if (oldentry.Length == jj_expentry.Length)
						{
							for (int i_1 = 0; i_1 < jj_expentry.Length; i_1++)
							{
								if (oldentry[i_1] != jj_expentry[i_1])
								{
									goto jj_entries_loop_continue;
								}
							}
							jj_expentries.AddItem(jj_expentry);
							goto jj_entries_loop_break;
						}
jj_entries_loop_continue: ;
					}
jj_entries_loop_break: ;
					if (pos != 0)
					{
						jj_lasttokens[(jj_endpos = pos) - 1] = kind;
					}
				}
			}
		}

		/// <summary>Generate ParseException.</summary>
		/// <remarks>Generate ParseException.</remarks>
		public virtual ParseException GenerateParseException()
		{
			jj_expentries.Clear();
			bool[] la1tokens = new bool[33];
			if (jj_kind >= 0)
			{
				la1tokens[jj_kind] = true;
				jj_kind = -1;
			}
			for (int i = 0; i < 21; i++)
			{
				if (jj_la1[i] == jj_gen)
				{
					for (int j = 0; j < 32; j++)
					{
						if ((jj_la1_0[i] & (1 << j)) != 0)
						{
							la1tokens[j] = true;
						}
						if ((jj_la1_1[i] & (1 << j)) != 0)
						{
							la1tokens[32 + j] = true;
						}
					}
				}
			}
			for (int i_1 = 0; i_1 < 33; i_1++)
			{
				if (la1tokens[i_1])
				{
					jj_expentry = new int[1];
					jj_expentry[0] = i_1;
					jj_expentries.AddItem(jj_expentry);
				}
			}
			jj_endpos = 0;
			Jj_rescan_token();
			Jj_add_error_token(0, 0);
			int[][] exptokseq = new int[jj_expentries.Count][];
			for (int i_2 = 0; i_2 < jj_expentries.Count; i_2++)
			{
				exptokseq[i_2] = jj_expentries[i_2];
			}
			return new ParseException(token, exptokseq, tokenImage);
		}

		/// <summary>Enable tracing.</summary>
		/// <remarks>Enable tracing.</remarks>
		public void Enable_tracing()
		{
		}

		/// <summary>Disable tracing.</summary>
		/// <remarks>Disable tracing.</remarks>
		public void Disable_tracing()
		{
		}

		private void Jj_rescan_token()
		{
			jj_rescan = true;
			for (int i = 0; i < 1; i++)
			{
				try
				{
					QueryParser.JJCalls p = jj_2_rtns[i];
					do
					{
						if (p.gen > jj_gen)
						{
							jj_la = p.arg;
							jj_lastpos = jj_scanpos = p.first;
							switch (i)
							{
								case 0:
								{
									Jj_3_1();
									break;
								}
							}
						}
						p = p.next;
					}
					while (p != null);
				}
				catch (QueryParser.LookaheadSuccess)
				{
				}
			}
			jj_rescan = false;
		}

		private void Jj_save(int index, int xla)
		{
			QueryParser.JJCalls p = jj_2_rtns[index];
			while (p.gen > jj_gen)
			{
				if (p.next == null)
				{
					p = p.next = new QueryParser.JJCalls();
					break;
				}
				p = p.next;
			}
			p.gen = jj_gen + xla - jj_la;
			p.first = token;
			p.arg = xla;
		}

		internal sealed class JJCalls
		{
			internal int gen;

			internal Token first;

			internal int arg;

			internal QueryParser.JJCalls next;
		}
	}
}
