/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
*/

namespace SF.Snowball.Ext
{
	/// <summary>
	/// This class was automatically generated by a Snowball to Java compiler
	/// It implements the stemming algorithm defined by a snowball script.
	/// </summary>
	/// <remarks>
	/// This class was automatically generated by a Snowball to Java compiler
	/// It implements the stemming algorithm defined by a snowball script.
	/// </remarks>
	public class IrishStemmer : SnowballProgram
	{
		private const long serialVersionUID = 1L;

		private static readonly IrishStemmer methodObject = new IrishStemmer();

		private static readonly Among[] a_0 =
		{ new Among("b'", -1, 4, string.Empty
		    , methodObject), new Among("bh", -1, 14, string.Empty, methodObject), new Among(
		        "bhf", 1, 9, string.Empty, methodObject), new Among("bp", -1, 11, string.Empty, 
		            methodObject), new Among("ch", -1, 15, string.Empty, methodObject), new Among("d'"
		                , -1, 2, string.Empty, methodObject), new Among("d'fh", 5, 3, string.Empty, methodObject
		                    ), new Among("dh", -1, 16, string.Empty, methodObject), new Among("dt", -1, 13, 
		                        string.Empty, methodObject), new Among("fh", -1, 17, string.Empty, methodObject)
		    , new Among("gc", -1, 7, string.Empty, methodObject), new Among("gh", -1, 18, string.Empty
		        , methodObject), new Among("h-", -1, 1, string.Empty, methodObject), new Among("m'"
		            , -1, 4, string.Empty, methodObject), new Among("mb", -1, 6, string.Empty, methodObject
		                ), new Among("mh", -1, 19, string.Empty, methodObject), new Among("n-", -1, 1, string.Empty
		                    , methodObject), new Among("nd", -1, 8, string.Empty, methodObject), new Among("ng"
		                        , -1, 10, string.Empty, methodObject), new Among("ph", -1, 20, string.Empty, methodObject
		                            ), new Among("sh", -1, 5, string.Empty, methodObject), new Among("t-", -1, 1, string.Empty
		                                , methodObject), new Among("th", -1, 21, string.Empty, methodObject), new Among(
		                                    "ts", -1, 12, string.Empty, methodObject) };

		private static readonly Among[] a_1 =
		{ new Among("\u00EDochta", -1, 1, 
		    string.Empty, methodObject), new Among("a\u00EDochta", 0, 1, string.Empty, methodObject
		        ), new Among("ire", -1, 2, string.Empty, methodObject), new Among("aire", 2, 2, 
		            string.Empty, methodObject), new Among("abh", -1, 1, string.Empty, methodObject)
		    , new Among("eabh", 4, 1, string.Empty, methodObject), new Among("ibh", -1, 1, string.Empty
		        , methodObject), new Among("aibh", 6, 1, string.Empty, methodObject), new Among(
		            "amh", -1, 1, string.Empty, methodObject), new Among("eamh", 8, 1, string.Empty, 
		                methodObject), new Among("imh", -1, 1, string.Empty, methodObject), new Among("aimh"
		                    , 10, 1, string.Empty, methodObject), new Among("\u00EDocht", -1, 1, string.Empty
		                        , methodObject), new Among("a\u00EDocht", 12, 1, string.Empty, methodObject), new 
		                            Among("ir\u00ED", -1, 2, string.Empty, methodObject), new Among("air\u00ED", 14, 
		                                2, string.Empty, methodObject) };

		private static readonly Among[] a_2 =
		{ new Among("\u00F3ideacha", -1, 
		    6, string.Empty, methodObject), new Among("patacha", -1, 5, string.Empty, methodObject
		        ), new Among("achta", -1, 1, string.Empty, methodObject), new Among("arcachta", 
		            2, 2, string.Empty, methodObject), new Among("eachta", 2, 1, string.Empty, methodObject
		                ), new Among("grafa\u00EDochta", -1, 4, string.Empty, methodObject), new Among("paite"
		                    , -1, 5, string.Empty, methodObject), new Among("ach", -1, 1, string.Empty, methodObject
		                        ), new Among("each", 7, 1, string.Empty, methodObject), new Among("\u00F3ideach"
		                            , 8, 6, string.Empty, methodObject), new Among("gineach", 8, 3, string.Empty, methodObject
		                                ), new Among("patach", 7, 5, string.Empty, methodObject), new Among("grafa\u00EDoch"
		                                    , -1, 4, string.Empty, methodObject), new Among("pataigh", -1, 5, string.Empty, 
		                                        methodObject), new Among("\u00F3idigh", -1, 6, string.Empty, methodObject), new 
		                                            Among("acht\u00FAil", -1, 1, string.Empty, methodObject), new Among("eacht\u00FAil"
		                                                , 15, 1, string.Empty, methodObject), new Among("gineas", -1, 3, string.Empty, methodObject
		                                                    ), new Among("ginis", -1, 3, string.Empty, methodObject), new Among("acht", -1, 
		                                                        1, string.Empty, methodObject), new Among("arcacht", 19, 2, string.Empty, methodObject
		                                                            ), new Among("eacht", 19, 1, string.Empty, methodObject), new Among("grafa\u00EDocht"
		                                                                , -1, 4, string.Empty, methodObject), new Among("arcachta\u00ED", -1, 2, string.Empty
		                                                                    , methodObject), new Among("grafa\u00EDochta\u00ED", -1, 4, string.Empty, methodObject
		                                                                        ) };

		private static readonly Among[] a_3 =
		{ new Among("imid", -1, 1, string.Empty
		    , methodObject), new Among("aimid", 0, 1, string.Empty, methodObject), new Among
		        ("\u00EDmid", -1, 1, string.Empty, methodObject), new Among("a\u00EDmid", 2, 1, 
		            string.Empty, methodObject), new Among("adh", -1, 2, string.Empty, methodObject)
		    , new Among("eadh", 4, 2, string.Empty, methodObject), new Among("faidh", -1, 1, 
		        string.Empty, methodObject), new Among("fidh", -1, 1, string.Empty, methodObject
		            ), new Among("\u00E1il", -1, 2, string.Empty, methodObject), new Among("ain", -1
		                , 2, string.Empty, methodObject), new Among("tear", -1, 2, string.Empty, methodObject
		                    ), new Among("tar", -1, 2, string.Empty, methodObject) };

		private static readonly char[] g_v =
		{ 17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 
		    0, 0, 0, 0, 0, 0, 1, 17, 4, 2 };

		private int I_p2;

		private int I_p1;

		private int I_pV;

		// This file was generated automatically by the Snowball to Java compiler
		private void Copy_from(IrishStemmer other)
		{
			I_p2 = other.I_p2;
			I_p1 = other.I_p1;
			I_pV = other.I_pV;
			base.copy_from(other);
		}

		private bool R_mark_regions()
		{
			int v_1;
			int v_3;
			// (, line 28
			I_pV = limit;
			I_p1 = limit;
			I_p2 = limit;
			// do, line 34
			v_1 = cursor;
			do
			{
				// (, line 34
				// gopast, line 35
				while (true)
				{
					do
					{
						if (!(in_grouping(g_v, 97, 250)))
						{
							goto lab2_break;
						}
						goto golab1_break;
lab2_continue: ;
					}
					while (false);
lab2_break: ;
					if (cursor >= limit)
					{
						goto lab0_break;
					}
					cursor++;
golab1_continue: ;
				}
golab1_break: ;
				// setmark pV, line 35
				I_pV = cursor;
lab0_continue: ;
			}
			while (false);
lab0_break: ;
			cursor = v_1;
			// do, line 37
			v_3 = cursor;
			do
			{
				// (, line 37
				// gopast, line 38
				while (true)
				{
					do
					{
						if (!(in_grouping(g_v, 97, 250)))
						{
							goto lab5_break;
						}
						goto golab4_break;
lab5_continue: ;
					}
					while (false);
lab5_break: ;
					if (cursor >= limit)
					{
						goto lab3_break;
					}
					cursor++;
golab4_continue: ;
				}
golab4_break: ;
				// gopast, line 38
				while (true)
				{
					do
					{
						if (!(out_grouping(g_v, 97, 250)))
						{
							goto lab7_break;
						}
						goto golab6_break;
lab7_continue: ;
					}
					while (false);
lab7_break: ;
					if (cursor >= limit)
					{
						goto lab3_break;
					}
					cursor++;
golab6_continue: ;
				}
golab6_break: ;
				// setmark p1, line 38
				I_p1 = cursor;
				// gopast, line 39
				while (true)
				{
					do
					{
						if (!(in_grouping(g_v, 97, 250)))
						{
							goto lab9_break;
						}
						goto golab8_break;
lab9_continue: ;
					}
					while (false);
lab9_break: ;
					if (cursor >= limit)
					{
						goto lab3_break;
					}
					cursor++;
golab8_continue: ;
				}
golab8_break: ;
				// gopast, line 39
				while (true)
				{
					do
					{
						if (!(out_grouping(g_v, 97, 250)))
						{
							goto lab11_break;
						}
						goto golab10_break;
lab11_continue: ;
					}
					while (false);
lab11_break: ;
					if (cursor >= limit)
					{
						goto lab3_break;
					}
					cursor++;
golab10_continue: ;
				}
golab10_break: ;
				// setmark p2, line 39
				I_p2 = cursor;
lab3_continue: ;
			}
			while (false);
lab3_break: ;
			cursor = v_3;
			return true;
		}

		private bool R_initial_morph()
		{
			int among_var;
			// (, line 43
			// [, line 44
			bra = cursor;
			// substring, line 44
			among_var = find_among(a_0, 24);
			if (among_var == 0)
			{
				return false;
			}
			// ], line 44
			ket = cursor;
			switch (among_var)
			{
				case 0:
				{
					return false;
				}

				case 1:
				{
					// (, line 46
					// delete, line 46
					slice_del();
					break;
				}

				case 2:
				{
					// (, line 50
					// delete, line 50
					slice_del();
					break;
				}

				case 3:
				{
					// (, line 52
					// <-, line 52
					slice_from("f");
					break;
				}

				case 4:
				{
					// (, line 55
					// delete, line 55
					slice_del();
					break;
				}

				case 5:
				{
					// (, line 58
					// <-, line 58
					slice_from("s");
					break;
				}

				case 6:
				{
					// (, line 61
					// <-, line 61
					slice_from("b");
					break;
				}

				case 7:
				{
					// (, line 63
					// <-, line 63
					slice_from("c");
					break;
				}

				case 8:
				{
					// (, line 65
					// <-, line 65
					slice_from("d");
					break;
				}

				case 9:
				{
					// (, line 67
					// <-, line 67
					slice_from("f");
					break;
				}

				case 10:
				{
					// (, line 69
					// <-, line 69
					slice_from("g");
					break;
				}

				case 11:
				{
					// (, line 71
					// <-, line 71
					slice_from("p");
					break;
				}

				case 12:
				{
					// (, line 73
					// <-, line 73
					slice_from("s");
					break;
				}

				case 13:
				{
					// (, line 75
					// <-, line 75
					slice_from("t");
					break;
				}

				case 14:
				{
					// (, line 79
					// <-, line 79
					slice_from("b");
					break;
				}

				case 15:
				{
					// (, line 81
					// <-, line 81
					slice_from("c");
					break;
				}

				case 16:
				{
					// (, line 83
					// <-, line 83
					slice_from("d");
					break;
				}

				case 17:
				{
					// (, line 85
					// <-, line 85
					slice_from("f");
					break;
				}

				case 18:
				{
					// (, line 87
					// <-, line 87
					slice_from("g");
					break;
				}

				case 19:
				{
					// (, line 89
					// <-, line 89
					slice_from("m");
					break;
				}

				case 20:
				{
					// (, line 91
					// <-, line 91
					slice_from("p");
					break;
				}

				case 21:
				{
					// (, line 93
					// <-, line 93
					slice_from("t");
					break;
				}
			}
			return true;
		}

		private bool R_RV()
		{
			if (!(I_pV <= cursor))
			{
				return false;
			}
			return true;
		}

		private bool R_R1()
		{
			if (!(I_p1 <= cursor))
			{
				return false;
			}
			return true;
		}

		private bool R_R2()
		{
			if (!(I_p2 <= cursor))
			{
				return false;
			}
			return true;
		}

		private bool R_noun_sfx()
		{
			int among_var;
			// (, line 103
			// [, line 104
			ket = cursor;
			// substring, line 104
			among_var = find_among_b(a_1, 16);
			if (among_var == 0)
			{
				return false;
			}
			// ], line 104
			bra = cursor;
			switch (among_var)
			{
				case 0:
				{
					return false;
				}

				case 1:
				{
					// (, line 108
					// call R1, line 108
					if (!R_R1())
					{
						return false;
					}
					// delete, line 108
					slice_del();
					break;
				}

				case 2:
				{
					// (, line 110
					// call R2, line 110
					if (!R_R2())
					{
						return false;
					}
					// delete, line 110
					slice_del();
					break;
				}
			}
			return true;
		}

		private bool R_deriv()
		{
			int among_var;
			// (, line 113
			// [, line 114
			ket = cursor;
			// substring, line 114
			among_var = find_among_b(a_2, 25);
			if (among_var == 0)
			{
				return false;
			}
			// ], line 114
			bra = cursor;
			switch (among_var)
			{
				case 0:
				{
					return false;
				}

				case 1:
				{
					// (, line 116
					// call R2, line 116
					if (!R_R2())
					{
						return false;
					}
					// delete, line 116
					slice_del();
					break;
				}

				case 2:
				{
					// (, line 118
					// <-, line 118
					slice_from("arc");
					break;
				}

				case 3:
				{
					// (, line 120
					// <-, line 120
					slice_from("gin");
					break;
				}

				case 4:
				{
					// (, line 122
					// <-, line 122
					slice_from("graf");
					break;
				}

				case 5:
				{
					// (, line 124
					// <-, line 124
					slice_from("paite");
					break;
				}

				case 6:
				{
					// (, line 126
					// <-, line 126
					slice_from("\u00F3id");
					break;
				}
			}
			return true;
		}

		private bool R_verb_sfx()
		{
			int among_var;
			// (, line 129
			// [, line 130
			ket = cursor;
			// substring, line 130
			among_var = find_among_b(a_3, 12);
			if (among_var == 0)
			{
				return false;
			}
			// ], line 130
			bra = cursor;
			switch (among_var)
			{
				case 0:
				{
					return false;
				}

				case 1:
				{
					// (, line 133
					// call RV, line 133
					if (!R_RV())
					{
						return false;
					}
					// delete, line 133
					slice_del();
					break;
				}

				case 2:
				{
					// (, line 138
					// call R1, line 138
					if (!R_R1())
					{
						return false;
					}
					// delete, line 138
					slice_del();
					break;
				}
			}
			return true;
		}

		public override bool Stem()
		{
			int v_1;
			int v_2;
			int v_3;
			int v_4;
			int v_5;
			// (, line 143
			// do, line 144
			v_1 = cursor;
			do
			{
				// call initial_morph, line 144
				if (!R_initial_morph())
				{
					goto lab0_break;
				}
lab0_continue: ;
			}
			while (false);
lab0_break: ;
			cursor = v_1;
			// do, line 145
			v_2 = cursor;
			do
			{
				// call mark_regions, line 145
				if (!R_mark_regions())
				{
					goto lab1_break;
				}
lab1_continue: ;
			}
			while (false);
lab1_break: ;
			cursor = v_2;
			// backwards, line 146
			limit_backward = cursor;
			cursor = limit;
			// (, line 146
			// do, line 147
			v_3 = limit - cursor;
			do
			{
				// call noun_sfx, line 147
				if (!R_noun_sfx())
				{
					goto lab2_break;
				}
lab2_continue: ;
			}
			while (false);
lab2_break: ;
			cursor = limit - v_3;
			// do, line 148
			v_4 = limit - cursor;
			do
			{
				// call deriv, line 148
				if (!R_deriv())
				{
					goto lab3_break;
				}
lab3_continue: ;
			}
			while (false);
lab3_break: ;
			cursor = limit - v_4;
			// do, line 149
			v_5 = limit - cursor;
			do
			{
				// call verb_sfx, line 149
				if (!R_verb_sfx())
				{
					goto lab4_break;
				}
lab4_continue: ;
			}
			while (false);
lab4_break: ;
			cursor = limit - v_5;
			cursor = limit_backward;
			return true;
		}

		public override bool Equals(object o)
		{
			return o is IrishStemmer;
		}

		public override int GetHashCode()
		{
			return typeof(IrishStemmer).FullName.GetHashCode();
		}
	}
}
